<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>ì¼ë³´ ì¢…í•©</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background:#f7f7f7; padding:20px; }
  h1 { font-size: 1.4rem; }
  textarea { width:100%; min-height:220px; padding:12px; font-size:14px; box-sizing:border-box; }
  button { padding:10px 14px; font-size:16px; margin-right:8px; cursor:pointer; }
  .result { white-space:pre-wrap; background:#fff; padding:12px; margin-top:12px; border-radius:6px; }
  .warning { margin-top:16px; padding:12px; background:#fff3cd; border:1px solid #ffeeba; border-radius:6px; }
</style>
</head>
<body>
<h1>ğŸ½ï¸ ì „ë„ í™œë™ ë³´ê³  ì¢…í•© ğŸ½ï¸</h1>

<p>ì•„ë˜ì— <b>ë³´ê³  í…ìŠ¤íŠ¸ ì „ì²´</b>ë¥¼ ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.</p>
<textarea id="input"></textarea>

<div style="margin-top:10px;">
  <button onclick="processReport()">â‡ï¸ ì¢…í•©í•˜ê¸°</button>
  <button onclick="copyResult()">ğŸ“‹ ê²°ê³¼ ë³µì‚¬</button>
</div>

<h3>ğŸ“‹ ì¢…í•© ê²°ê³¼</h3>
<div id="output" class="result"></div>
<div id="warnings" class="warning" style="display:none;"></div>

<script>
// ===== íŒŒì„œ =====
function parseLine(line) {
  const parts = line.split('/');
  return {
    zone: parts[0],
    leader: parts[1],
    has: parts[2],
    find: parts[3],
    invite: parts[4],
    meet: parts[5],
    step: parts[6],
    counsel: parts[7],
    word: parts[8],
    center: parts[9]
  };
}

function extractNames(cell) {
  if (!cell || !cell.includes('(')) return [];
  const inside = cell.slice(cell.indexOf('(') + 1, cell.lastIndexOf(')'));
  if (!inside.trim()) return [];
  return inside.split(/\s+/).map(v => {
    const m = v.match(/(.+?)([0-9]+\.?5?)/);
    if (!m) return null;
    return { name: m[1], value: parseFloat(m[2]) };
  }).filter(Boolean);
}

// ===== ë°ì´í„° êµ¬ì¡° =====
function buildIndex(rows) {
  const index = {};
  rows.forEach(r => {
    const fields = ['find','invite','meet','step','counsel','word','center'];
    fields.forEach(f => {
      extractNames(r[f]).forEach(e => {
        if (!index[e.name]) index[e.name] = [];
        index[e.name].push({ zone: r.zone, field: f, value: e.value });
      });
    });
  });
  return index;
}

// ===== ì¢…í•© ê³„ì‚° =====
function sumCell(cell) {
  if (!cell) return 0;
  const m = cell.match(/[0-9]+(\.5)?/);
  return m ? parseFloat(m[0]) : 0;
}

function calcTotal(rows) {
  const totals = { has:0, find:0, invite:0, meet:0, step:0, counsel:0, word:0, center:0 };
  rows.forEach(r=>{
    totals.has += sumCell(r.has);
    totals.find += sumCell(r.find);
    totals.invite += sumCell(r.invite);
    totals.meet += sumCell(r.meet);
    totals.step += sumCell(r.step);
    totals.counsel += sumCell(r.counsel);
    totals.word += sumCell(r.word);
    totals.center += sumCell(r.center);
  });
  return totals;
}

// ===== ê²½ê³  â‘  ì—­í•  ì¶©ëŒ =====
function roleConflict(index) {
  const warnings = [];
  Object.entries(index).forEach(([name, logs]) => {
    const zones = [...new Set(logs.map(l=>l.zone))];
    if (zones.length <= 1) return;
    const fields = new Set(logs.map(l=>l.field));
    if (fields.size > 1) warnings.push({ name, detail: logs });
  });
  return warnings;
}

// ===== ê²½ê³  â‘¡ .5 ë‹¨ë… =====
function halfSolo(index) {
  const warnings = [];
  Object.entries(index).forEach(([name, logs])=>{
    const halfLogs = logs.filter(l=>l.value===0.5);
    if (halfLogs.length === 1) {
      const l = halfLogs[0];
      warnings.push({ name, zone: l.zone, field: l.field });
    }
  });
  return warnings;
}

// ===== ì‹¤í–‰ í•¨ìˆ˜ =====
function processReport() {
  const input = document.getElementById('input').value;
  const lines = input.split('\n').filter(l=>l.trim());
  const rows = lines.filter(l=> /^\d+\//.test(l)).map(parseLine);
  const index = buildIndex(rows);
  const total = calcTotal(rows);

  // ===== ì¢…í•© ì¤„ ìƒì„± =====
  const totalLine = 'ì¢…í•©/' +
    [total.has,total.find,total.invite,total.meet,total.step,total.counsel,total.word,total.center]
    .map(v=>v % 1 ? v.toFixed(1) : v).join('/');

  let outputLines = lines.map(l => l.startsWith('ì¢…í•©/') ? totalLine : l);
  document.getElementById('output').textContent = outputLines.join('\n');

  // ===== ê²½ê³  ìƒì„± =====
  const roleWarnings = roleConflict(index);
  const halfWarnings = halfSolo(index);

  // ===== ì¢…í•© ì†Œìˆ˜ì  ì²´í¬ ëˆ„ë½ =====
  const totalWarnings = [];
  Object.entries(total).forEach(([k,v])=>{
    if (v % 1 !== 0) totalWarnings.push(`â€¢ ì¢…í•©ì´ ì†Œìˆ˜ì (${v})ì…ë‹ˆë‹¤. ëˆ„ë½ì´ë‚˜ .5 ë‹¨ë…ì„ í™•ì¸í•˜ì„¸ìš”.`);
  });

  const warnDiv = document.getElementById('warnings');
  const messages = [];

  if (roleWarnings.length) {
    messages.push('ğŸš¨ ê¸°ì¡´ ê²½ê³ ');
    roleWarnings.forEach(w=>{
      messages.push(`${w.name}`);
      const grouped = {};
      w.detail.forEach(d=>{
        if (!grouped[d.zone]) grouped[d.zone]=[];
        grouped[d.zone].push(d.field);
      });
      Object.entries(grouped).forEach(([zone, fields])=>{
        messages.push(`- ${zone}êµ¬ì—­ â†’ ${fields.join(', ')}`);
      });
    });
  }

  if (halfWarnings.length) {
    messages.push('\nâš ï¸ ë³´ê³  ëˆ„ë½ ì˜ì‹¬');
    halfWarnings.forEach(w=>{
      messages.push(`â€¢ ${w.name}.5(${w.zone}êµ¬ì—­) â†’ ${w.field}`);
    });
  }

  if (totalWarnings.length) {
    messages.push('\nâš ï¸ ì¢…í•© ì†Œìˆ˜ì ');
    totalWarnings.forEach(m=>messages.push(m));
  }

  if (messages.length) {
    warnDiv.style.display='block';
    warnDiv.textContent = messages.join('\n');
  } else {
    warnDiv.style.display='none';
  }
}

// ===== ë³µì‚¬ ê¸°ëŠ¥ =====
function copyResult() {
  const text = document.getElementById('output').textContent;
  navigator.clipboard.writeText(text).then(()=>alert('âœ… ë³µì‚¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.'));
}
</script>
</body>
</html>
