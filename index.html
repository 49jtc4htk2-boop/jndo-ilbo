<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì „ë„ í™œë™ ë³´ê³  ì¢…í•©</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background:#f7f7f7; padding:20px; }
    h1 { font-size: 1.4rem; }
    textarea { width:100%; min-height:220px; padding:12px; font-size:14px; box-sizing:border-box; }
    button { padding:10px 14px; font-size:16px; margin-right:8px; cursor:pointer; }
    .result { white-space:pre-wrap; background:#fff; padding:12px; margin-top:12px; border-radius:6px; }
    .warning { margin-top:16px; padding:12px; background:#fff3cd; border:1px solid #ffeeba; border-radius:6px; }
  </style>
</head>
<body>
  <h1>ğŸŒ³ ì „ë„ í™œë™ ë³´ê³  ì¢…í•© ğŸŒ³</h1>

  <p>ì•„ë˜ì— <b>ë³´ê³  í…ìŠ¤íŠ¸ ì „ì²´</b>ë¥¼ ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.</p>
  <textarea id="input"></textarea>

  <div style="margin-top:10px;">
    <button onclick="processReport()">â‡ï¸ ì¢…í•©í•˜ê¸°</button>
    <button onclick="copyResult()">ğŸ“‹ ê²°ê³¼ ë³µì‚¬</button>
  </div>

  <h3>ğŸ“‹ ì¢…í•© ê²°ê³¼</h3>
  <div id="output" class="result"></div>

  <div id="warnings" class="warning" style="display:none;"></div>

<script>
function processReport() {
  const input = document.getElementById('input').value;
  const lines = input.split('\n');

  const headers = ['ì„­ì™¸ìë³´ìœ ','ë‹¹ì¼ ì°¾ê¸°','ë‹¹ì¼ ì„­ì™¸','ë‹¹ì¼ ë§Œë‚¨','ë‹¹ì¼ ë‹¨ê³„í–¥ìƒ ë§Œë‚¨','ìƒë‹´ë”°ê¸°','ë§ì”€ë”°ê¸°','ì„¼í„°í™•ë‹µ'];
  const totals = Array(headers.length).fill(0);

  // name -> area -> Set(columns)
  const roleMap = {};
  const halfRecords = {};

  const dataRows = [];

  // ===== ë°ì´í„° íŒŒì‹± =====
  lines.forEach(line => {
    if (/^\d+\//.test(line)) {
      const cols = line.split('/');
      const area = cols[0];
      const row = { area };
      headers.forEach((header, i) => {
        row[header] = cols[i + 2] || '0';
        const cell = row[header];
        const matches = [...cell.matchAll(/([0-9.]+)\(([^)]+)\)/g)];
        if (matches.length) {
          matches.forEach(m => {
            const val = parseFloat(m[1]);
            const names = m[2].trim().split(/\s+/);
            names.forEach(n => {
              const name = n.replace(/[0-9.]/g,'');
              if (!roleMap[name]) roleMap[name] = {};
              if (!roleMap[name][area]) roleMap[name][area] = new Set();
              roleMap[name][area].add(header);

              if (val === 0.5) {
                if (!halfRecords[name]) halfRecords[name] = [];
                halfRecords[name].push({ area, header });
              }
            });
            totals[i] += val;
          });
        } else {
          totals[i] += parseFloat(cell) || 0;
        }
      });
      dataRows.push(row);
    }
  });

  // ===== ì¢…í•© í–‰ ìƒì„± =====
  let totalLine = 'ì¢…í•©/' + totals.map((v,i) => {
    if (i >= 5) { // ë§ˆì§€ë§‰ 3ê°œ ì¹¸ ì´ë¦„ í¬í•¨
      const names = Object.entries(roleMap)
        .filter(([_, areas]) => Object.values(areas).some(set => set.has(headers[i])))
        .map(([name]) => name);
      return names.length ? `${v}(${[...new Set(names)].join(' ')})` : `${v}`;
    }
    return v;
  }).join('/');

  const outputLines = lines.map(l => l.startsWith('ì¢…í•©/') ? totalLine : l);
  document.getElementById('output').textContent = outputLines.join('\n');

  // ===== ê²½ê³  íŒë‹¨ =====
  const warnings = [];
  Object.entries(roleMap).forEach(([name, areas]) => {
    const areaKeys = Object.keys(areas);
    if (areaKeys.length < 2) return; // í•œ êµ¬ì—­ë§Œ ìˆìœ¼ë©´ ê²½ê³  ì•„ë‹˜
    const roleSets = areaKeys.map(a => ({ area: a, roles: new Set([...areas[a]].filter(r=>r!=='ì„­ì™¸ìë³´ìœ ')) }));
    const baseRoles = roleSets[0].roles;
    let mismatch = false;
    roleSets.forEach(rs => {
      if (rs.roles.size !== baseRoles.size) mismatch = true;
      for (let r of rs.roles) if (!baseRoles.has(r)) mismatch = true;
    });
    if (mismatch) {
      let block = `${name}`;
      roleSets.forEach(rs => {
        if (rs.roles.size) block += `\n- ${rs.area}êµ¬ì—­ â†’ ${[...rs.roles].join(', ')}`;
      });
      warnings.push(block);
    }
  });

  // ===== ëˆ„ë½ ì˜ì‹¬ (.5 ë‹¨ë…) =====
  const halfWarnings = [];
  Object.entries(halfRecords).forEach(([name, recs]) => {
    if (recs.length === 1) {
      const r = recs[0];
      halfWarnings.push(`${name}.5(${r.area}êµ¬ì—­) â†’ ${r.header}`);
    }
  });

  // ===== ì¶œë ¥ =====
  const warnDiv = document.getElementById('warnings');
  let warnText = '';
  if (warnings.length) {
    warnText += 'ğŸš¨ ê¸°ì¡´ ê²½ê³ \n\n' + warnings.join('\n\n') + '\n\n';
  }
  if (halfWarnings.length) {
    warnText += 'âš ï¸ ëˆ„ë½ ì˜ì‹¬\n\n' + halfWarnings.join('\n');
  }

  if (warnText) {
    warnDiv.style.display = 'block';
    warnDiv.textContent = warnText;
  } else {
    warnDiv.style.display = 'none';
  }
}

function copyResult() {
  const text = document.getElementById('output').textContent;
  navigator.clipboard.writeText(text).then(()=> alert('âœ… ë³µì‚¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.'));
}
</script>
</body>
</html>
