<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì¼ë³´ ì¢…í•©</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background:#f7f7f7; padding:20px; }
    h1 { font-size: 1.4rem; }
    textarea { width:100%; min-height:220px; padding:12px; font-size:14px; box-sizing:border-box; }
    button { padding:10px 14px; font-size:14px; margin-right:8px; cursor:pointer; }
    .result { white-space:pre-wrap; background:#fff; padding:12px; margin-top:12px; border-radius:6px; }
    .warning { margin-top:16px; padding:12px; background:#fff3cd; border:1px solid #ffeeba; border-radius:6px; }
  </style>
</head>
<body>

<h1>ğŸ½ï¸ ì „ë„ í™œë™ ë³´ê³  ì¢…í•© ğŸ½ï¸</h1>

<p>ì•„ë˜ì— <b>ë³´ê³  í…ìŠ¤íŠ¸ ì „ì²´</b>ë¥¼ ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.</p>
<textarea id="input"></textarea>

<div style="margin-top:10px;">
  <button onclick="processReport()">â‡ï¸ ì¢…í•©í•˜ê¸°</button>
  <button onclick="copyResult()">ğŸ“‹ ê²°ê³¼ ë³µì‚¬</button>
</div>

<h3>ğŸ“‹ ì¢…í•© ê²°ê³¼</h3>
<div id="output" class="result"></div>

<div id="warnings" class="warning" style="display:none;"></div>

<script>
// ================= íŒŒì„œ =================
function parseLine(line) {
  const p = line.split('/');
  return {
    zone: p[0],
    has: p[2],
    find: p[3],
    invite: p[4],
    meet: p[5],
    step: p[6],
    counsel: p[7],
    word: p[8],
    center: p[9]
  };
}

function extract(cell) {
  if (!cell || !cell.includes('(')) return [];
  const inside = cell.slice(cell.indexOf('(') + 1, cell.lastIndexOf(')'));
  return inside.split(/\s+/).map(v => {
    const m = v.match(/^(.+?)([0-9]+\.5|[0-9]+)$/);
    if (!m) return null;
    return { name: m[1], value: parseFloat(m[2]) };
  }).filter(Boolean);
}

// ================= ì¸ë±ìŠ¤ =================
function buildIndex(rows) {
  const index = {};
  const fields = ['find','invite','meet','step','counsel','word','center'];

  rows.forEach(r => {
    fields.forEach(f => {
      extract(r[f]).forEach(e => {
        if (!index[e.name]) index[e.name] = [];
        index[e.name].push({ zone: r.zone, field: f, value: e.value });
      });
    });
  });
  return index;
}

// ================= ì¢…í•© =================
function cellSum(cell) {
  if (!cell) return 0;
  const m = cell.match(/^[0-9]+(\.5)?/);
  return m ? Math.floor(parseFloat(m[0])) : 0;
}

function calcTotal(rows) {
  const t = { has:0, find:0, invite:0, meet:0, step:0, counsel:0, word:0, center:0 };
  rows.forEach(r => {
    t.has += cellSum(r.has);
    t.find += cellSum(r.find);
    t.invite += cellSum(r.invite);
    t.meet += cellSum(r.meet);
    t.step += cellSum(r.step);
    t.counsel += cellSum(r.counsel);
    t.word += cellSum(r.word);
    t.center += cellSum(r.center);
  });
  return t;
}

// ================= ê²½ê³  =================
function roleConflict(index) {
  let res = [];
  Object.entries(index).forEach(([name, logs]) => {
    const zones = new Set(logs.map(l => l.zone));
    const fields = new Set(logs.map(l => l.field));
    if (zones.size > 1 && fields.size > 1) {
      res.push({ name, logs });
    }
  });
  return res;
}

function halfSolo(index) {
  let res = [];
  Object.entries(index).forEach(([name, logs]) => {
    const half = logs.filter(l => l.value === 0.5);
    if (half.length === 1) res.push(half[0]);
  });
  return res;
}

// ================= ì‹¤í–‰ =================
function processReport() {
  const text = document.getElementById('input').value.trim();
  if (!text) return alert('ë³´ê³  ë‚´ìš©ì„ ë¶™ì—¬ë„£ì–´ ì£¼ì„¸ìš”.');

  const lines = text.split('\n').filter(l => /^\d+\//.test(l));
  const rows = lines.map(parseLine);

  const index = buildIndex(rows);
  const total = calcTotal(rows);

  document.getElementById('output').textContent =
    `ì¢…í•©/${total.has}/${total.find}/${total.invite}/${total.meet}/${total.step}/${total.counsel}/${total.word}/${total.center}`;

  const warn = [];
  const role = roleConflict(index);
  const half = halfSolo(index);

  if (role.length) {
    let t = 'ğŸš¨ ê¸°ì¡´ ê²½ê³ \n';
    role.forEach(r => {
      t += `\nâ€¢ ${r.name}\n`;
      r.logs.forEach(l => t += `  - ${l.zone}êµ¬ì—­ â†’ ${l.field}\n`);
    });
    warn.push(t);
  }

  if (half.length) {
    let t = 'ğŸŸ¡ ëˆ„ë½ ì˜ì‹¬ ëª…ë‹¨\n';
    half.forEach(h => {
      t += `\nâ€¢ ${h.name}.5 (${h.zone}êµ¬ì—­) â†’ ${h.field} : ëª‡ êµ¬ì—­ì´ë‘ í•˜ì…¨ë‚˜ìš”?\n`;
    });
    warn.push(t);
  }

  const w = document.getElementById('warnings');
  if (warn.length) {
    w.style.display = 'block';
    w.textContent = warn.join('\n\n');
  } else {
    w.style.display = 'none';
  }
}

function copyResult() {
  const t = document.getElementById('output').textContent;
  if (!t) return alert('ë³µì‚¬í•  ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.');
  navigator.clipboard.writeText(t).then(() =>
    alert('âœ… ë³µì‚¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.')
  );
}
</script>

</body>
</html>
