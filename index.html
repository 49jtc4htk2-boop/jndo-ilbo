<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì „ë„ í™œë™ ë³´ê³  ì¢…í•©</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background:#f7f7f7;
      padding:20px;
    }
    h1 { font-size: 1.4rem; }
    textarea {
      width:100%;
      min-height:220px;
      padding:12px;
      font-size:14px;
      box-sizing:border-box;
    }
    button {
      padding:10px 14px;
      font-size:14px;
      margin-right:8px;
      cursor:pointer;
    }
    .result {
      white-space:pre-wrap;
      background:#fff;
      padding:12px;
      margin-top:12px;
      border-radius:6px;
    }
    .warning {
      margin-top:16px;
      padding:12px;
      background:#fff3cd;
      border:1px solid #ffeeba;
      border-radius:6px;
      white-space:pre-wrap;
    }
  </style>
</head>
<body>

<h1>ğŸŒ³ ì „ë„ í™œë™ ë³´ê³  ì¢…í•© ğŸŒ³</h1>

<p>ì•„ë˜ì— <b>ë³´ê³  í…ìŠ¤íŠ¸ ì „ì²´</b>ë¥¼ ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.</p>
<textarea id="input"></textarea>

<div style="margin-top:10px;">
  <button onclick="processReport()">ì¢…í•©í•˜ê¸°</button>
  <button onclick="copyResult()">ğŸ“‹ ê²°ê³¼ ë³µì‚¬</button>
</div>

<h3>ğŸ“‹ ì¢…í•© ê²°ê³¼</h3>
<div id="output" class="result"></div>

<div id="warnings" class="warning" style="display:none;"></div>

<script>
function processReport() {
  const input = document.getElementById('input').value;
  const lines = input.split(/\n/);

  const headers = [
    'ì„­ì™¸ìë³´ìœ ',
    'ë‹¹ì¼ ì°¾ê¸°',
    'ë‹¹ì¼ ì„­ì™¸',
    'ë‹¹ì¼ ë§Œë‚¨',
    'ë‹¹ì¼ ë‹¨ê³„í–¥ìƒ ë§Œë‚¨',
    'ìƒë‹´ë”°ê¸°',
    'ë§ì”€ë”°ê¸°',
    'ì„¼í„°í™•ë‹µ'
  ];

  const totals = Array(headers.length).fill(0);

  // name -> area -> Set(roles)
  const roleMap = {};
  let outputLines = [];

  /* =====================
     ë°ì´í„° íŒŒì‹±
  ===================== */
  for (let line of lines) {
    if (/^\d+\//.test(line)) {
      const cols = line.split('/');
      const area = cols[0];

      headers.forEach((header, i) => {
        const cell = cols[i + 2] || '0';
        const matches = [...cell.matchAll(/([0-9.]+)\(([^)]+)\)/g)];

        if (matches.length === 0) {
          const val = parseFloat(cell);
          if (!isNaN(val)) totals[i] += val;
        } else {
          matches.forEach(m => {
            const val = parseFloat(m[1]);
            totals[i] += val;

            const name = m[2].replace(/[0-9.]/g, '').trim();

            if (!roleMap[name]) roleMap[name] = {};
            if (!roleMap[name][area]) roleMap[name][area] = new Set();
            roleMap[name][area].add(header);
          });
        }
      });
    }
  }

  /* =====================
     ì¢…í•© ì¤„ ìƒì„±
     (ë§ˆì§€ë§‰ 3ì¹¸ ì´ë¦„ í‘œì‹œ)
  ===================== */
  const totalLine =
    'ì¢…í•©/' +
    totals.map((v, i) => {
      if (i >= 5) {
        const names = Object.entries(roleMap)
          .filter(([_, areas]) =>
            Object.values(areas).some(set => set.has(headers[i]))
          )
          .map(([name]) => name);

        return names.length
          ? `${v}(${[...new Set(names)].join(' ')})`
          : `${v}`;
      }
      return `${v}`;
    }).join('/');

  for (let line of lines) {
    if (line.startsWith('ì¢…í•©/')) outputLines.push(totalLine);
    else outputLines.push(line);
  }

  document.getElementById('output').textContent =
    outputLines.join('\n');

  /* =====================
     âš ï¸ ê²½ê³  íŒë‹¨ (ìµœì¢… ê¸°ì¤€)
     ===================== */
  const warningLines = [];

  Object.entries(roleMap).forEach(([name, areas]) => {
    const areaEntries = Object.entries(areas)
      .map(([area, roles]) => ({
        area,
        roles: [...roles].filter(r => r !== 'ì„­ì™¸ìë³´ìœ ')
      }))
      .filter(e => e.roles.length > 0);

    if (areaEntries.length < 2) return;

    const flattened = [];

    areaEntries.forEach(e => {
      // ê°™ì€ êµ¬ì—­ ë‚´ ì°¾ê¸° + ì„­ì™¸ë§Œ ìˆëŠ” ê²½ìš° í—ˆìš©
      if (
        e.roles.length === 2 &&
        e.roles.includes('ë‹¹ì¼ ì°¾ê¸°') &&
        e.roles.includes('ë‹¹ì¼ ì„­ì™¸')
      ) return;

      e.roles.forEach(role => {
        flattened.push({
          name,
          area: e.area,
          role
        });
      });
    });

    if (flattened.length < 2) return;

    flattened.forEach(e => {
      warningLines.push(
        `${e.name}(${e.area}êµ¬ì—­) â†’ ${e.role}`
      );
    });
  });

  const warnDiv = document.getElementById('warnings');
  if (warningLines.length) {
    warnDiv.style.display = 'block';
    warnDiv.textContent =
      'âš ï¸ í™•ì¸ í•„ìš” ì‚¬í•­\n\n' +
      [...new Set(warningLines)].join('\n');
  } else {
    warnDiv.style.display = 'none';
  }
}

function copyResult() {
  const text = document.getElementById('output').textContent;
  navigator.clipboard.writeText(text).then(() => {
    alert('âœ… ë³µì‚¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
  });
}
</script>
</body>
</html>
